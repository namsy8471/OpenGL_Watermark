#version 430 core
layout(local_size_x = 8, local_size_y = 8, local_size_z = 1) in;

#define BLOCK_SIZE 8
#define BLOCK_SIZE_FLOAT 8.0f
#define PI 3.14159265359f
// 정규화 상수 미리 계산
#define SQRT1_N 0.35355339f  // 1 / sqrt(8)
#define SQRT2_N 0.5f         // sqrt(2 / 8)

// 입력: 원본(0), 마킹(1)
layout(binding = 0, rgba32f) uniform readonly image2D img_original;
layout(binding = 1, rgba32f) uniform readonly image2D img_marked;

// 출력: 비트 버퍼
layout(std430, binding = 2) buffer ExtractedBits { uint out_bits[]; };
// 패턴 버퍼 제거 (1.0 고정 사용)

uniform uint Width, Height;
uniform uint BitSize;

// 공유 메모리
shared float BlockOrg[8][8];
shared float BlockMark[8][8];

void main() {
    // WorkGroup ID 사용 (블록 좌표 고정)
    ivec3 gid = ivec3(gl_WorkGroupID);
    ivec3 tid = ivec3(gl_LocalInvocationID);
    
    // 1. 이미지 로드 & Y(Luma) 변환
    // 각 스레드가 자신의 위치에 해당하는 픽셀 1개를 로드해서 공유 메모리에 저장
    uint bx = gid.x * 8; 
    uint by = gid.y * 8;
    
    vec3 p1 = imageLoad(img_original, ivec2(bx + tid.x, by + tid.y)).rgb;
    vec3 p2 = imageLoad(img_marked,   ivec2(bx + tid.x, by + tid.y)).rgb;
    
    BlockOrg[tid.y][tid.x]  = 0.299*p1.r + 0.587*p1.g + 0.114*p1.b;
    BlockMark[tid.y][tid.x] = 0.299*p2.r + 0.587*p2.g + 0.114*p2.b;
    
    // 모든 스레드가 로드를 마칠 때까지 대기
    barrier();

    // 2. DCT 계산 및 추출 (스레드 0,0이 단독 수행)
    // 8x8 블록 전체를 순회하며 (1, 2) 주파수 계수 하나만 계산함
    if (tid.x == 0 && tid.y == 0) {
        
        // 타겟 주파수 좌표 (u=1, v=2) - Embed와 일치해야 함
        float u = 1.0; 
        float v = 2.0;
        
        float sum_org = 0.0;
        float sum_mark = 0.0;
        
        // 정규화 계수 (u, v가 0이 아니므로 둘 다 SQRT2_N 사용)
        float Cu = SQRT2_N;
        float Cv = SQRT2_N;

        // DCT-II 수식 직접 계산
        for(int y=0; y<8; ++y) {
            for(int x=0; x<8; ++x) {
                float angleX = PI * (2.0*float(x)+1.0) * u / 16.0;
                float angleY = PI * (2.0*float(y)+1.0) * v / 16.0;
                float factor = cos(angleX) * cos(angleY);
                
                sum_org  += BlockOrg[y][x] * factor;
                sum_mark += BlockMark[y][x] * factor;
            }
        }
        
        float coeff_org  = Cu * Cv * sum_org;
        float coeff_mark = Cu * Cv * sum_mark;
        
        // 3. 추출 (Hybrid Logic)
        float diff = coeff_mark - coeff_org;
        float pattern = 1.0; 
        float correlation = 0.0;

        // 원본 값이 0에 가까우면(Additive) 그냥 차이값 사용
        // 원본 값이 있으면(Multiplicative) 부호를 곱해서 방향성 확인
        if (abs(coeff_org) < 1e-5) correlation = diff * pattern;
        else                       correlation = diff * pattern * sign(coeff_org);
        
        // 결과 판별 (0보다 크면 1, 아니면 0)
        uint detected = (correlation >= 0.0) ? 1 : 0;
        
        // 저장
        uint numBlocksX = (Width + 8 - 1) / 8;
        uint blockIdx = gid.y * numBlocksX + gid.x;
        
        if (blockIdx < BitSize) {
            out_bits[blockIdx] = detected;
        }
    }
}