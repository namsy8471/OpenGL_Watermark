#version 430 core
layout(local_size_x = 8, local_size_y = 8, local_size_z = 1) in;

layout(binding = 0, rgba32f) uniform readonly image2D img_original;
layout(binding = 1, rgba32f) uniform readonly image2D img_marked;
layout(std430, binding = 2) buffer ExtractedBits { uint out_bits[]; };

uniform uint Width, Height;
uniform uint BitSize;

void Haar1D(in float src[8], out float dst[8]) {
    for(int i=0; i<4; ++i) {
        dst[i]   = (src[2*i] + src[2*i+1]) * 0.5;
        dst[4+i] = (src[2*i] - src[2*i+1]) * 0.5;
    }
}

shared float BlockOrg[8][8];
shared float BlockMark[8][8];

void main() {
    // Legacy는 WorkGroup 단위로 블록 좌표 계산 (중요!)
    ivec3 gid = ivec3(gl_WorkGroupID); 
    ivec3 tid = ivec3(gl_LocalInvocationID);
    
    uint bx = gid.x * 8; 
    uint by = gid.y * 8;

    // 1. 로드 & Y 변환
    vec3 p1 = imageLoad(img_original, ivec2(bx+tid.x, by+tid.y)).rgb;
    vec3 p2 = imageLoad(img_marked,   ivec2(bx+tid.x, by+tid.y)).rgb;
    BlockOrg[tid.y][tid.x]  = 0.299*p1.r + 0.587*p1.g + 0.114*p1.b;
    BlockMark[tid.y][tid.x] = 0.299*p2.r + 0.587*p2.g + 0.114*p2.b;
    barrier();

    // 2. DWT 수행 (Row -> Col)
    float rowO[8], rowM[8], resO[8], resM[8];
    for(int i=0; i<8; ++i) { rowO[i] = BlockOrg[tid.y][i]; rowM[i] = BlockMark[tid.y][i]; }
    Haar1D(rowO, resO); Haar1D(rowM, resM);
    barrier(); 
    for(int i=0; i<8; ++i) { BlockOrg[tid.y][i] = resO[i]; BlockMark[tid.y][i] = resM[i]; }
    barrier();

    for(int i=0; i<8; ++i) { rowO[i] = BlockOrg[i][tid.x]; rowM[i] = BlockMark[i][tid.x]; }
    Haar1D(rowO, resO); Haar1D(rowM, resM);
    barrier();
    for(int i=0; i<8; ++i) { BlockOrg[i][tid.x] = resO[i]; BlockMark[i][tid.x] = resM[i]; }
    barrier();

    // 3. 추출 (스레드 0,0 단독 수행)
    if (tid.x == 0 && tid.y == 0) {
        uint numBlocksX = (Width + 8 - 1) / 8;
        uint blockIdx = gid.y * numBlocksX + gid.x;
        
        // ★ 단일 타겟 (4, 4) - Embed와 일치시킴
        uint u = 4;
        uint v = 4;

        float val_org  = BlockOrg[v][u];
        float val_mark = BlockMark[v][u];
        float diff = val_mark - val_org;
        
        // ★ 패턴 1.0 고정
        float pattern = 1.0;
        float correlation = 0.0;

        // 하이브리드 로직 대응
        if (abs(val_org) < 1e-5) correlation = diff * pattern;
        else                     correlation = diff * pattern * sign(val_org);
        
        // 부등호 방향 확인 (정상: >= 0.0)
        uint detected = (correlation >= 0.0) ? 1 : 0;
        
        if (blockIdx < BitSize) out_bits[blockIdx] = detected;
    }
}