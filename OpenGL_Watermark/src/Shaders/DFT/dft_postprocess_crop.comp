#version 430 core
layout(local_size_x = 32, local_size_y = 32) in;

// Input 0: FFT를 거쳐 돌아온 "변형된 명도(Y')" (2048 size)
layout(rg32f, binding = 0) readonly uniform image2D img_padded;

// Output: 최종 컬러 이미지 (1920 size)
layout(rgba32f, binding = 1) writeonly uniform image2D img_final;

// Input 2: "원본 색상"을 빌려오기 위한 원본 텍스처 (1920 size)
layout(rgba32f, binding = 2) readonly uniform image2D img_src;

uniform uint SrcWidth, SrcHeight;
uniform uint PaddedSize;

void main() {
    ivec2 pos = ivec2(gl_GlobalInvocationID.xy);
    if (pos.x >= SrcWidth || pos.y >= SrcHeight) return;

    // 1. FFT 결과에서 "워터마킹된 명도(Y')" 가져오기
    // (정규화 포함: PaddedSize제곱으로 나눔)
    float scale = 1.0 / float(PaddedSize * PaddedSize);
    float newY = imageLoad(img_padded, pos).x * scale;

    // 2. 원본 이미지에서 RGB 가져오기
    vec3 srcRGB = imageLoad(img_src, pos).rgb;

    // 3. RGB -> YCbCr 변환 (색상 정보 추출)
    // Y는 버리고 Cb, Cr만 취함
    float Cb = -0.168736 * srcRGB.r - 0.331264 * srcRGB.g + 0.500000 * srcRGB.b;
    float Cr =  0.500000 * srcRGB.r - 0.418688 * srcRGB.g - 0.081312 * srcRGB.b;

    // 4. YCbCr -> RGB 역변환 (새로운 Y + 원래 CbCr)
    vec3 finalRGB;
    finalRGB.r = newY + 1.402 * Cr;
    finalRGB.g = newY - 0.344136 * Cb - 0.714136 * Cr;
    finalRGB.b = newY + 1.772 * Cb;

    // 5. 저장 (Alpha=1.0 필수)
    imageStore(img_final, pos, vec4(finalRGB, 1.0));
}