#version 430 core
layout(local_size_x = 8, local_size_y = 8) in;

layout(rgba32f, binding = 0) readonly uniform image2D img_src;
layout(rgba32f, binding = 1) writeonly uniform image2D img_dst;

// 워터마크 데이터 버퍼
layout(std430, binding = 2) buffer BitStream { uint bits[]; };

uniform uint Width, Height;
uniform float Strength; // 강도 (예: 5.0)
uniform uint Embed;     // 1: 삽입 모드, 0: 변환만 테스트
uniform uint BitSize;   // 비트 배열 크기

struct Mat4 { float m[4][4]; };

// 행렬 곱셈 C = A * B
void MatMul(in Mat4 A, in Mat4 B, out Mat4 C) {
    for (int r = 0; r < 4; r++) {
        for (int c = 0; c < 4; c++) {
            C.m[r][c] = A.m[r][0] * B.m[0][c] + A.m[r][1] * B.m[1][c] +
                        A.m[r][2] * B.m[2][c] + A.m[r][3] * B.m[3][c];
        }
    }
}

// 전치 행렬
void Transpose(in Mat4 A, out Mat4 T) {
    for(int i=0; i<4; i++) for(int j=0; j<4; j++) T.m[i][j] = A.m[j][i];
}

void main() {
    ivec2 blkPos = ivec2(gl_GlobalInvocationID.xy) * 4;
    if (blkPos.x >= Width || blkPos.y >= Height) return;

    // 1. RGB 로드 및 Y(Luminance) 추출
    Mat4 Y_block;
    vec3 originRGB[16]; // 컬러 복원을 위해 원본 저장

    for (int y = 0; y < 4; y++) {
        for (int x = 0; x < 4; x++) {
            vec3 p = imageLoad(img_src, blkPos + ivec2(x, y)).rgb;
            originRGB[y*4 + x] = p;
            Y_block.m[y][x] = 0.299*p.r + 0.587*p.g + 0.114*p.b; 
        }
    }

    // 2. DCT 변환 행렬 (T) 정의
    Mat4 T;
    float a = 0.5;
    float b = 0.65328148;
    float c = 0.27059805;

    T.m[0][0]=a; T.m[0][1]=a;  T.m[0][2]=a;   T.m[0][3]=a;
    T.m[1][0]=b; T.m[1][1]=c;  T.m[1][2]=-c;  T.m[1][3]=-b;
    T.m[2][0]=a; T.m[2][1]=-a; T.m[2][2]=-a;  T.m[2][3]=a;
    T.m[3][0]=c; T.m[3][1]=-b; T.m[3][2]=b;   T.m[3][3]=-c;

    Mat4 T_trans;
    Transpose(T, T_trans);

    // 3. Forward DCT: Coeffs = T * Y * T^T
    Mat4 Temp, Coeffs;
    MatMul(T, Y_block, Temp);
    MatMul(Temp, T_trans, Coeffs);

    if (Embed == 1) {
        uint stride = gl_NumWorkGroups.x * 8; 
        uint bitIdx = (gl_GlobalInvocationID.y * stride + gl_GlobalInvocationID.x) % BitSize;
    
        // 비트 값 (-1.0 or 1.0)
        float w = (bits[bitIdx] == 1) ? 1.0 : -1.0;
        float alpha = Strength * 0.00051;

        // ★ Spread Spectrum: 3개의 계수에 분산 삽입
        // 타겟: (1,2), (2,1), (2,2) -> 중간 주파수 대역
        // 루프(for)를 쓰지 않고 직접 명시해야 레지스터 최적화가 유지됨
    
        // ---------------------------------------------------------
        // Target 1: (1, 2)
        // ---------------------------------------------------------
        float val1 = Coeffs.m[1][2];
        // 패턴: (+1)을 곱한다고 가정
        if (abs(val1) < 1e-5) Coeffs.m[1][2] = val1 + (alpha * 0.5 * w);       // Additive
        else                  Coeffs.m[1][2] = val1 * (1.0 + alpha * w);       // Multiplicative

        // ---------------------------------------------------------
        // Target 2: (2, 1) - 대칭되는 위치
        // ---------------------------------------------------------
        float val2 = Coeffs.m[2][1];
        // 패턴: 여기는 (-1)을 곱해서 패턴을 꼰다고 가정 (선택사항)
        // 단순하게 가려면 여기도 w 그대로 사용
        if (abs(val2) < 1e-5) Coeffs.m[2][1] = val2 + (alpha * 0.5 * w);
        else                  Coeffs.m[2][1] = val2 * (1.0 + alpha * w);

        // ---------------------------------------------------------
        // Target 3: (1, 1) - 약간 저주파 쪽 (강인성 증가)
        // ---------------------------------------------------------
        float val3 = Coeffs.m[1][1];
        if (abs(val3) < 1e-5) Coeffs.m[1][1] = val3 + (alpha * 0.5 * w);
        else                  Coeffs.m[1][1] = val3 * (1.0 + alpha * w);
    }

    // 5. Inverse DCT: Y_new = T^T * Coeffs * T
    Mat4 Y_new;
    MatMul(T_trans, Coeffs, Temp);
    MatMul(Temp, T, Y_new);

    // 6. 컬러 복원 및 저장
    for (int y = 0; y < 4; y++) {
        for (int x = 0; x < 4; x++) {
            float oldY = Y_block.m[y][x];
            float newY = Y_new.m[y][x];
            vec3 rgb = originRGB[y*4 + x];

            // 0으로 나누기 방지
            if (oldY > 1e-5) {
                rgb *= (newY / oldY); // 밝기 비율만큼 RGB 스케일링
            } else {
                // 검은색에 가까운 경우 그냥 밝기만 더해줌 (예외 처리)
                rgb += (newY - oldY);
            }
            
            imageStore(img_dst, blkPos + ivec2(x, y), vec4(rgb, 1.0));
        }
    }
}