#version 430 core
layout(local_size_x = 8, local_size_y = 8, local_size_z = 1) in;

// --- 상수 ---
#define BLOCK_SIZE 8
#define BLOCK_SIZE_FLOAT 8.0f
#define PI 3.14159265359f
#define SQRT1_N (1.0f / sqrt(BLOCK_SIZE_FLOAT))
#define SQRT2_N (sqrt(2.0f / BLOCK_SIZE_FLOAT))

// --- 입출력 ---
// (Pass 3의 출력이 Pass 4의 입력이 됨)
layout(binding = 0, rgba32f) uniform readonly image2D IntermediateBufferRGB;
// (최종 출력 텍스처)
layout(binding = 1, rgba32f) uniform writeonly image2D FinalOutput;

// --- 유니폼 ---
uniform uint Width;
uniform uint Height;

// --- 공유 메모리 ---
shared vec3 SharedBlockRGB_Pass4[BLOCK_SIZE][BLOCK_SIZE];

// --- 1D IDCT 함수 (Pass 3과 동일) ---
float Do_IDCT_1D_Single(float inputData[BLOCK_SIZE], uint n_idx)
{
    float n = float(n_idx);
    float sum = 0.0f;
    for (uint k = 0; k < BLOCK_SIZE; ++k)
    {
        float K_float = float(k);
        float Ck = (K_float == 0.0f) ? SQRT1_N : SQRT2_N;
        float angle_term = PI * (2.0f * n + 1.0f) * K_float / (2.0f * BLOCK_SIZE_FLOAT);
        sum += Ck * inputData[k] * cos(angle_term);
    }
    return sum;
}

// --- 메인 커널 ---
void main()
{
    ivec3 groupID = ivec3(gl_WorkGroupID);
    ivec3 groupThreadID = ivec3(gl_LocalInvocationID);
    
    uint blockOriginX = groupID.x * BLOCK_SIZE;
    uint blockOriginY = groupID.y * BLOCK_SIZE;
    uint threadX = groupThreadID.x;
    uint threadY = groupThreadID.y;

    // 1. 전역 메모리(Intermediate) -> 공유 메모리 로드
    uint loadX = blockOriginX + threadX;
    uint loadY = blockOriginY + threadY;
    vec3 loadedRGBPrime = vec3(0, 0, 0);
    if (loadX < Width && loadY < Height)
    {
        loadedRGBPrime = imageLoad(IntermediateBufferRGB, ivec2(loadX, loadY)).rgb;
    }
    SharedBlockRGB_Pass4[threadY][threadX] = loadedRGBPrime;

    // 2. 동기화
    barrier();

    // 3. 공유 메모리 -> 로컬 배열 로드 (행 기준) 및 1D IDCT
    float rowDataR[BLOCK_SIZE], rowDataG[BLOCK_SIZE], rowDataB[BLOCK_SIZE];
    for (uint i = 0; i < BLOCK_SIZE; ++i)
    {
        rowDataR[i] = SharedBlockRGB_Pass4[threadY][i].r;
        rowDataG[i] = SharedBlockRGB_Pass4[threadY][i].g;
        rowDataB[i] = SharedBlockRGB_Pass4[threadY][i].b;
    }
    
    float idctR = Do_IDCT_1D_Single(rowDataR, threadX);
    float idctG = Do_IDCT_1D_Single(rowDataG, threadX);
    float idctB = Do_IDCT_1D_Single(rowDataB, threadX);
    
    // HLSL의 saturate(x) -> GLSL의 clamp(x, 0.0, 1.0)
    vec3 finalPixel = clamp(vec3(idctR, idctG, idctB), 0.0, 1.0);

    // 4. 최종 결과 쓰기 (Alpha 1.0 추가)
    uint writeX = blockOriginX + threadX;
    uint writeY = blockOriginY + threadY;
    if (writeX < Width && writeY < Height)
    {
        imageStore(FinalOutput, ivec2(writeX, writeY), vec4(finalPixel, 1.0f));

    }
}