#version 430 core
layout(local_size_x = 8, local_size_y = 8, local_size_z = 1) in;

// --- 상수 ---
#define BLOCK_SIZE 8
#define BLOCK_SIZE_FLOAT 8.0f
#define PI 3.14159265359f
#define SQRT1_N (1.0f / sqrt(BLOCK_SIZE_FLOAT))
#define SQRT2_N (sqrt(2.0f / BLOCK_SIZE_FLOAT))

// --- 입출력 (HLSL -> GLSL) ---
// (Pass 1의 출력이 Pass 2의 입력이 됨)
layout(binding = 0, rgba32f) uniform readonly image2D IntermediateBufferRGB;
layout(binding = 1, rgba32f) uniform writeonly image2D DCTOutputRGB;

// --- 버퍼 (HLSL StructuredBuffer -> GLSL SSBO) ---
layout(std430, binding = 2) buffer BitstreamBuffer { 
    uint Bitstream[]; // C++에서 보낸 비트스트림
} bitstream_buf;

layout(std430, binding = 3) buffer PatternBuffer { 
    float PatternBuffer[]; // C++에서 보낸 확산 패턴
} pattern_buf;

// --- 유니폼 (C++에서 설정) ---
uniform float EmbeddingStrength;
uniform uint CoefficientsToUse;
uniform uint Width;
uniform uint Height;
uniform uint BitLength;
uniform uint Embed; // 0 = 끄기, 1 = 켜기

// --- 지그재그 스캔 순서 (HLSL과 동일, uvec2로 번역) ---
const uvec2 ZigZagIndices[63] = uvec2[](
    uvec2(0, 1), uvec2(1, 0), uvec2(2, 0), uvec2(1, 1), uvec2(0, 2), uvec2(0, 3), uvec2(1, 2), uvec2(2, 1),
    uvec2(3, 0), uvec2(4, 0), uvec2(3, 1), uvec2(2, 2), uvec2(1, 3), uvec2(0, 4), uvec2(0, 5), uvec2(1, 4),
    uvec2(2, 3), uvec2(3, 2), uvec2(4, 1), uvec2(5, 0), uvec2(6, 0), uvec2(5, 1), uvec2(4, 2), uvec2(3, 3),
    uvec2(2, 4), uvec2(1, 5), uvec2(0, 6), uvec2(0, 7), uvec2(1, 6), uvec2(2, 5), uvec2(3, 4), uvec2(4, 3),
    uvec2(5, 2), uvec2(6, 1), uvec2(7, 0), uvec2(7, 1), uvec2(6, 2), uvec2(5, 3), uvec2(4, 4), uvec2(3, 5),
    uvec2(2, 6), uvec2(1, 7), uvec2(2, 7), uvec2(3, 6), uvec2(4, 5), uvec2(5, 4), uvec2(6, 3), uvec2(7, 2),
    uvec2(7, 3), uvec2(6, 4), uvec2(5, 5), uvec2(4, 6), uvec2(3, 7), uvec2(4, 7), uvec2(5, 6), uvec2(6, 5),
    uvec2(7, 4), uvec2(7, 5), uvec2(6, 6), uvec2(5, 7), uvec2(6, 7), uvec2(7, 6), uvec2(7, 7)
);

// --- 공유 메모리 (HLSL -> GLSL) ---
shared vec3 SharedBlockRGB_Pass2[BLOCK_SIZE][BLOCK_SIZE];

// --- 1D DCT 함수 (Pass 1과 동일) ---
float Do_DCT_1D_Single(float inputData[BLOCK_SIZE], uint k_idx)
{
    float k = float(k_idx);
    float Ck = (k == 0.0f) ? SQRT1_N : SQRT2_N;
    float sum = 0.0f;
    for (uint n = 0; n < BLOCK_SIZE; ++n)
    {
        float n_float = float(n);
        float angle_term = PI * (2.0f * n_float + 1.0f) * k / (2.0f * BLOCK_SIZE_FLOAT);
        sum += inputData[n] * cos(angle_term);
    }
    return Ck * sum;
}

// --- 메인 커널 ---
void main()
{
    ivec3 groupID = ivec3(gl_WorkGroupID);
    ivec3 groupThreadID = ivec3(gl_LocalInvocationID);
    
    uint blockOriginX = groupID.x * BLOCK_SIZE;
    uint blockOriginY = groupID.y * BLOCK_SIZE;
    uint threadX = groupThreadID.x; // 열 (x)
    uint threadY = groupThreadID.y; // 행 (y)

    // 1. 전역 메모리 -> 공유 메모리 로드 (Pass 1의 결과)
    uint loadX = blockOriginX + threadX;
    uint loadY = blockOriginY + threadY;
    vec3 loadedRGB = vec3(0, 0, 0);
    if (loadX < Width && loadY < Height)
    {
        loadedRGB = imageLoad(IntermediateBufferRGB, ivec2(loadX, loadY)).rgb;
    }
    SharedBlockRGB_Pass2[threadY][threadX] = loadedRGB;

    // 2. 동기화
    barrier();

    // 3. 공유 메모리 -> 로컬 배열 로드 (열 기준) 및 1D DCT
    float colDataR[BLOCK_SIZE], colDataG[BLOCK_SIZE], colDataB[BLOCK_SIZE];
    for (uint i = 0; i < BLOCK_SIZE; ++i)
    {
        colDataR[i] = SharedBlockRGB_Pass2[i][threadX].r;
        colDataG[i] = SharedBlockRGB_Pass2[i][threadX].g;
        colDataB[i] = SharedBlockRGB_Pass2[i][threadX].b;
    }

    float dctResultColR = Do_DCT_1D_Single(colDataR, threadY);
    float dctResultColG = Do_DCT_1D_Single(colDataG, threadY);
    float dctResultColB = Do_DCT_1D_Single(colDataB, threadY);

    vec3 dctResult = vec3(dctResultColR, dctResultColG, dctResultColB);

    /// 4. 임베딩 로직 수정 (Y 기준 통합 제어)
    vec3 finalCoefficientToWrite = dctResult;
    
    if (Embed == 1)
    {
        uint numBlocksX = (Width + BLOCK_SIZE - 1) / BLOCK_SIZE;
        uint blockLinearIndex = groupID.y * numBlocksX + groupID.x;

        if (blockLinearIndex < BitLength)
        {
            // 타겟: (1, 2) 단일 계수
            if (threadX == 1 && threadY == 2) 
            {
                uint bit = bitstream_buf.Bitstream[blockLinearIndex];
                float bit_sign = (bit == 1) ? 1.0f : -1.0f;
                float pattern_value = 1.0; 
                //float alpha = EmbeddingStrength * 0.0046; // For FHD
                float alpha = EmbeddingStrength * 0.00207; // For 4K

                // 1. 현재 블록의 '밝기(Y) 계수'를 계산
                // DCT는 선형이므로, RGB 계수에서 바로 Y 계수를 구할 수 있음
                float Y_coeff = 0.299 * finalCoefficientToWrite.r + 
                                0.587 * finalCoefficientToWrite.g + 
                                0.114 * finalCoefficientToWrite.b;

                // 2. Y 계수에 대해 목표값 계산 (하이브리드)
                float Y_target = Y_coeff;
                float term = alpha * bit_sign * pattern_value;

                if (abs(Y_coeff) < 1e-5) {
                    // Additive (0일 때)
                    Y_target += (term * 0.5); 
                } else {
                    // Multiplicative (값이 있을 때)
                    // 부호(sign)는 Y_coeff 기준!
                    Y_target *= (1.0 + alpha * bit_sign * pattern_value); 
                    // 위 식은 Y_target = Y * (1 + term) 과 같음 (단, sign 처리가 필요할 수 있음)
                    // 정확히는: Y_target = Y + Y * term? No.
                    // Multiplicative 정석: Y_new = Y + abs(Y) * term 
                    // (이렇게 해야 Y가 음수일 때도 w=1이면 '커지는' 방향(양수쪽)으로 감? 
                    //  아니면 절대값이 커지는 방향? -> 보통 절대값 증가가 강건함)
                    
                    // 여기서는 가장 단순하게 "부호 방향으로 밀기" 적용
                    // Y가 양수면 +term, 음수면 -term (즉, 절대값 증가)
                    // 추출기: diff * sign(Y) > 0 확인하므로, 절대값을 키워야 함.
                    Y_target = Y_coeff * (1.0 + alpha); // 단순 증폭 (w에 따라 부호 바뀜? 아님)
                    
                    // [정석 코드] w=1 -> 절대값 증가, w=-1 -> 절대값 감소
                    if (bit == 1) Y_target = Y_coeff * (1.0 + alpha);
                    else          Y_target = Y_coeff * (1.0 - alpha);
                }

                // 3. 차이(Delta) 계산
                float diff = Y_target - Y_coeff;

                // 4. RGB에 똑같이 분배 (색상 유지하면서 밝기만 조절)
                finalCoefficientToWrite.r += diff;
                finalCoefficientToWrite.g += diff;
                finalCoefficientToWrite.b += diff;
            }
        }
    }

    // 5. 결과 쓰기
    uint writeX = blockOriginX + threadX;
    uint writeY = blockOriginY + threadY;
    if (writeX < Width && writeY < Height)
    {
        // 4채널(RGBA)로 저장
        imageStore(DCTOutputRGB, ivec2(writeX, writeY), vec4(finalCoefficientToWrite, 0.0));
    }
}