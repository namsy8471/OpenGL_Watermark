#version 430 core
layout(local_size_x = 8, local_size_y = 8, local_size_z = 1) in;

// --- 상수 ---
#define BLOCK_SIZE 8
#define HALF_BLOCK_SIZE 4
#define HAAR_SCALE 0.5f

// --- 입출력 ---
layout(binding = 0, rgba32f) uniform readonly image2D Source;
layout(binding = 1, rgba32f) uniform writeonly image2D IntermediateBuffer; // DWT용 중간 버퍼

// --- 유니폼 ---
uniform uint Width;
uniform uint Height;

// --- 공유 메모리 ---
shared vec3 SharedBlockRGB[BLOCK_SIZE][BLOCK_SIZE];

void main()
{
    ivec3 groupID = ivec3(gl_WorkGroupID);
    ivec3 groupThreadID = ivec3(gl_LocalInvocationID);
    
    uint blockX = groupID.x * BLOCK_SIZE;
    uint blockY = groupID.y * BLOCK_SIZE;
    uint threadX = groupThreadID.x; // 열
    uint threadY = groupThreadID.y; // 행 (이 스레드가 처리할 행)

    // 1. 전역 메모리 -> 공유 메모리 로드
    uint loadX = blockX + threadX;
    uint loadY = blockY + threadY;
    vec3 pixelRGB = vec3(0, 0, 0);
    if (loadX < Width && loadY < Height)
    {
        pixelRGB = imageLoad(Source, ivec2(loadX, loadY)).rgb;
    }
    SharedBlockRGB[threadY][threadX] = pixelRGB;
    barrier(); // 동기화

    // 2. 공유 메모리 -> 로컬 배열 로드 (행 기준)
    float rowDataR[BLOCK_SIZE], rowDataG[BLOCK_SIZE], rowDataB[BLOCK_SIZE];
    for (uint i = 0; i < BLOCK_SIZE; ++i)
    {
        rowDataR[i] = SharedBlockRGB[threadY][i].r;
        rowDataG[i] = SharedBlockRGB[threadY][i].g;
        rowDataB[i] = SharedBlockRGB[threadY][i].b;
    }
    
    // 3. ★ Haar DWT 1D (Inlined) ★
    float tempR[BLOCK_SIZE], tempG[BLOCK_SIZE], tempB[BLOCK_SIZE];
    for (uint i = 0; i < HALF_BLOCK_SIZE; ++i)
    {
        float aR = rowDataR[2 * i]; float bR = rowDataR[2 * i + 1];
        float aG = rowDataG[2 * i]; float bG = rowDataG[2 * i + 1];
        float aB = rowDataB[2 * i]; float bB = rowDataB[2 * i + 1];
        
        tempR[i] = (aR + bR) * HAAR_SCALE; // Approx
        tempG[i] = (aG + bG) * HAAR_SCALE;
        tempB[i] = (aB + bB) * HAAR_SCALE;
        
        tempR[i + HALF_BLOCK_SIZE] = (aR - bR) * HAAR_SCALE; // Detail
        tempG[i + HALF_BLOCK_SIZE] = (aG - bG) * HAAR_SCALE;
        tempB[i + HALF_BLOCK_SIZE] = (aB - bB) * HAAR_SCALE;
    }
    // (결과를 다시 rowData로 복사할 필요 없음. temp를 바로 씀)

    // 4. 결과를 IntermediateBuffer에 쓰기
    uint writeX = blockX + threadX;
    uint writeY = blockY + threadY;
    if (writeX < Width && writeY < Height)
    {
        // 스레드의 열(threadX) 위치에 해당하는 변환 결과 저장
        vec3 result = vec3(tempR[threadX], tempG[threadX], tempB[threadX]);
        imageStore(IntermediateBuffer, ivec2(writeX, writeY), vec4(result, 0.0));
    }
}