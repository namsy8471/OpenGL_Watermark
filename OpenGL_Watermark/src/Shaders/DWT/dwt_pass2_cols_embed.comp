#version 430 core
layout(local_size_x = 8, local_size_y = 8, local_size_z = 1) in;

#define BLOCK_SIZE 8
#define HALF_BLOCK_SIZE 4
#define HAAR_SCALE 0.5f

layout(binding = 0, rgba32f) uniform readonly image2D IntermediateBuffer;
layout(binding = 1, rgba32f) uniform writeonly image2D DWTOutput;

layout(std430, binding = 2) buffer BitstreamBuffer { uint Bitstream[]; } bitstream_buf;
// 패턴 버퍼 사용 안 함 (1.0 고정)

uniform float EmbeddingStrength;
uniform uint Width;
uniform uint Height;
uniform uint BitLength;
uniform uint Embed;

shared vec3 SharedBlockRGB[BLOCK_SIZE][BLOCK_SIZE];

void main()
{
    ivec3 groupID = ivec3(gl_WorkGroupID);
    ivec3 tid = ivec3(gl_LocalInvocationID);
    
    uint blockX = groupID.x * BLOCK_SIZE;
    uint blockY = groupID.y * BLOCK_SIZE;
    uint threadX = tid.x; 
    uint threadY = tid.y;

    // 1. 로드
    uint loadX = blockX + threadX;
    uint loadY = blockY + threadY;
    vec3 loadedRGB = vec3(0);
    if (loadX < Width && loadY < Height) {
        loadedRGB = imageLoad(IntermediateBuffer, ivec2(loadX, loadY)).rgb;
    }
    SharedBlockRGB[threadY][threadX] = loadedRGB;
    barrier();

    // 2. Transpose & DWT (Column transform implies working on Rows first in shared mem logic usually, 
    // but assuming pass1 did rows, this pass does cols. 
    // This part depends on your specific implementation of Pass 2. 
    // Assuming standard Pass 2 structure provided before.)
    
    float colDataR[BLOCK_SIZE], colDataG[BLOCK_SIZE], colDataB[BLOCK_SIZE];
    for (uint i = 0; i < BLOCK_SIZE; ++i) {
        colDataR[i] = SharedBlockRGB[i][threadX].r;
        colDataG[i] = SharedBlockRGB[i][threadX].g;
        colDataB[i] = SharedBlockRGB[i][threadX].b;
    }
    
    // Haar DWT 1D
    float tempR[BLOCK_SIZE], tempG[BLOCK_SIZE], tempB[BLOCK_SIZE];
    for (uint i = 0; i < HALF_BLOCK_SIZE; ++i) {
        float aR = colDataR[2 * i]; float bR = colDataR[2 * i + 1];
        float aG = colDataG[2 * i]; float bG = colDataG[2 * i + 1];
        float aB = colDataB[2 * i]; float bB = colDataB[2 * i + 1];
        
        tempR[i] = (aR + bR) * HAAR_SCALE;
        tempG[i] = (aG + bG) * HAAR_SCALE;
        tempB[i] = (aB + bB) * HAAR_SCALE;
        
        tempR[i + HALF_BLOCK_SIZE] = (aR - bR) * HAAR_SCALE;
        tempG[i + HALF_BLOCK_SIZE] = (aG - bG) * HAAR_SCALE;
        tempB[i + HALF_BLOCK_SIZE] = (aB - bB) * HAAR_SCALE;
    }

    vec3 finalDwtCoeffRGB = vec3(tempR[threadY], tempG[threadY], tempB[threadY]);

    // 5. 임베딩 (Y 기준 통합 제어)
    if (Embed == 1) 
    {
        // 타겟: (4, 4) HH 밴드 (Legacy Extract와 좌표 일치 필수!)
        if (threadX == 4 && threadY == 4) 
        {
            uint numBlocksX = (Width + BLOCK_SIZE - 1) / BLOCK_SIZE;
            uint blockLinearIndex = groupID.y * numBlocksX + groupID.x;

            if (blockLinearIndex < BitLength)
            {
                uint bit = bitstream_buf.Bitstream[blockLinearIndex];
                // 1이면 증폭(1+a), 0이면 감쇄(1-a)
                
                //float alpha = EmbeddingStrength * 0.0011; // For FHD
                float alpha = EmbeddingStrength * 0.00088; // For 4K

                // 1. Y 계수 계산
                float Y_coeff = 0.299 * finalDwtCoeffRGB.r + 
                                0.587 * finalDwtCoeffRGB.g + 
                                0.114 * finalDwtCoeffRGB.b;

                // 2. 목표 Y값 계산
                float Y_target = Y_coeff;
                
                // Additive (0 근처)
                if (abs(Y_coeff) < 1e-5) {
                    // 0일 때는 강제로 값을 만듦
                    // bit=1 -> 양수, bit=0 -> 음수
                    float w = (bit == 1) ? 1.0 : -1.0;
                    Y_target += (alpha * 0.5 * w);
                } 
                // Multiplicative
                else {
                    // bit=1 -> 절대값 증가, bit=0 -> 절대값 감소
                    if (bit == 1) Y_target = Y_coeff * (1.0 + alpha);
                    else          Y_target = Y_coeff * (1.0 - alpha);
                }

                // 3. 차이 적용
                float diff = Y_target - Y_coeff;
                finalDwtCoeffRGB.r += diff;
                finalDwtCoeffRGB.g += diff;
                finalDwtCoeffRGB.b += diff;
            }
        }
    }

    // 4. 저장
    uint writeX = blockX + threadX;
    uint writeY = blockY + threadY;
    if (writeX < Width && writeY < Height) {
        imageStore(DWTOutput, ivec2(writeX, writeY), vec4(finalDwtCoeffRGB, 0.0));
    }
}